-module({{packageName}}_jesse_validator_swagger_2_0).

-behaviour(jesse_schema_validator).

%% API
-export([check_value/3]).
-export([options/0]).
-export([make_schema_ref/2]).

-define(DISCRIMINATOR, <<"discriminator">>).
-define(NOT_FOUND, not_found).

-spec options() ->
    [{validator, module()} | {validator_state, []}].
options() ->
    [
        {validator, ?MODULE},
        {validator_state, []}
    ].

-spec make_schema_ref(RefBase, Element) -> Ref when
    RefBase :: string(),
    Element :: string(),
    Ref     :: string().
make_schema_ref(RefBase, Element) ->
    RefBase ++ "#/definitions/" ++ Element.

-spec check_value(Value, JsonSchema, State) ->
    {Value, JsonSchema, State} | no_return()
when
    Value      :: any(),
    JsonSchema :: jesse:json_term(),
    State      :: jesse_state:state().
check_value(Value, [{?DISCRIMINATOR, DiscrField} | Attrs], State) ->
  {NewAttrs, NewState} = case jesse_lib:is_json_object(Value) of
      true  -> check_discriminator(Value, DiscrField, Attrs, State);
      false -> {Attrs, State}
  end,
  {Value, NewAttrs, NewState};
check_value(Value, JsonSchema, State) ->
  jesse_validator_draft4:check_value(Value, JsonSchema, State).

check_discriminator(Value, DiscrField, Attrs, State) when is_binary(DiscrField) ->
    case get_value(DiscrField, Value) of
        ?NOT_FOUND ->
            {Attrs, State};
        SchemaName ->
            validate_discriminator(Value, {DiscrField, SchemaName}, State, Attrs)
    end.

validate_discriminator(Value, Discriminator, State, Attrs) ->
    case get_discriminator(State) of
        Discriminator ->
            %% Got back here from the child schema ref, skip further validation.
            {[], State};
        _ ->
            {Attrs, check_child_schema(Value, Discriminator, State)}
    end.

check_child_schema(Value, Discriminator = {_, SchemaName}, State) ->
  State1 = add_discriminator(State, Discriminator),
  Schema = make_ref_schema(<<"#/definitions/", SchemaName/binary>>),
  State2 = jesse_schema_validator:validate_with_state(Schema, Value, State1),
  remove_last_discriminator(State2).

get_value(Key, Schema) ->
  jesse_json_path:value(Key, Schema, ?NOT_FOUND).

add_discriminator(State, Discriminator) ->
  Path = jesse_state:get_validator_state(State),
  jesse_state:set_validator_state(State, [Discriminator | Path]).

remove_last_discriminator(State) ->
  case jesse_state:get_validator_state(State) of
      [_ | Rest] ->
          jesse_state:set_validator_state(State, Rest);
      [] ->
          State
  end.

get_discriminator(State) ->
  case jesse_state:get_validator_state(State) of
      [Discriminator | _] ->
          Discriminator;
      [] ->
          undefined
  end.

make_ref_schema(Ref) ->
    [{<<"$ref">>, Ref}].


-ifdef(TEST).
-include_lib("eunit/include/eunit.hrl").

-define(SCHEMA,
  <<"{\"definitions\": {
       \"Pet\": {
         \"type\":          \"object\",
         \"discriminator\": \"type\",
         \"properties\": {
            \"name\":    {\"type\": \"string\"},
            \"owner\":   {\"$ref\": \"#/definitions/Owner\"},
            \"petType\": {\"type\": \"string\"}
         },
         \"required\": [\"name\", \"type\"]
       },
       \"Cat\": {
         \"description\": \"A representation of a cat\",
         \"allOf\": [
           {\"$ref\": \"#/definitions/Pet\"},
           {
             \"type\":       \"object\",
             \"properties\": {
               \"huntingSkill\": {
                 \"type\":        \"string\",
                 \"description\": \"The measured skill for hunting\",
                 \"default\":     \"lazy\",
                 \"enum\":        [\"clueless\", \"lazy\", \"adventurous\", \"aggressive\"]
               }
             },
             \"required\": [\"huntingSkill\"]
           }
         ]
       },
       \"Dog\": {
         \"description\": \"A representation of a dog\",
         \"allOf\": [
           {\"$ref\": \"#/definitions/Pet\"},
           {
             \"type\":       \"object\",
             \"properties\": {
               \"packSize\": {
                 \"type\":        \"integer\",
                 \"format\":      \"int32\",
                 \"description\": \"the size of the pack the dog is from\",
                 \"default\":     0,
                 \"minimum\":     0
               }
             }
           }
         ],
         \"required\": [\"packSize\"]
       },
       \"Owner\": {
         \"type\":          \"object\",
         \"discriminator\": \"type\",
         \"properties\": {
            \"soleOwner\": {\"type\": \"boolean\"},
            \"type\": {\"type\": \"string\"}
         },
         \"required\": [\"soleOwner\", \"type\"]
       },
       \"Family\": {
         \"allOf\": [
           {\"$ref\": \"#/definitions/Owner\"},
           {
             \"type\":       \"object\",
             \"properties\": {
               \"members\": {
                 \"type\":  \"array\",
                 \"items\": {\"$ref\": \"#/definitions/Person\"},
                 \"minItems\": 1
               }
             },
             \"required\": [\"members\"]
           }
         ]
       },
       \"Person\": {
         \"allOf\": [
           {\"$ref\": \"#/definitions/Owner\"},
           {
             \"type\":       \"object\",
             \"properties\": {
               \"name\": {\"type\": \"string\"},
               \"age\":  {
                 \"type\":    \"integer\",
                 \"minimum\": 0,
                 \"maximum\": 150
               },
               \"sex\": {
                 \"type\": \"string\",
                 \"enum\": [\"male\", \"female\"]
               },
               \"legalStatus\": {\"$ref\": \"#/definitions/LegalStatus\"}
             },
             \"required\": [\"age\", \"sex\"]
           }
         ]
       },
       \"LegalStatus\": {
         \"type\":          \"object\",
         \"discriminator\": \"status\",
         \"properties\": {
            \"status\": {\"type\": \"string\"}
         },
         \"required\": [\"status\"]
       },
       \"Single\": {
         \"allOf\": [
           {\"$ref\": \"#/definitions/LegalStatus\"},
           {
             \"type\":       \"object\",
             \"properties\": {
               \"minor\": {\"type\": \"boolean\"}
             },
             \"required\": [\"minor\"]
           }
         ]
       },
       \"Married\": {
         \"allOf\": [
           {\"$ref\": \"#/definitions/LegalStatus\"},
           {
             \"type\":       \"object\",
             \"properties\": {
               \"partnerName\": {\"type\": \"string\"}
             },
             \"required\": [\"partnerName\"]
           }
         ]
       }
     }}">>).
-define(SCHEMA_KEY, "pet.schema").
-define(PET_SCHEMA, "Pet").

init_jesse() ->
    jesse:add_schema(?SCHEMA_KEY, ?SCHEMA, [{parser_fun, fun jsx:decode/1}]).

validate(DefName, Value) ->
    ok = init_jesse(),
    case jesse:validate_ref(make_schema_ref(?SCHEMA_KEY, DefName), Value, options()) of
        {ok, Value}    -> Value;
        {error, Error} -> Error
    end.

exception(BadSchema, BadData, PropertyPath) ->
    [{
        data_invalid,
        make_ref_schema(BadSchema),
        all_schemas_not_valid,
        BadData,
        PropertyPath
     }].

%% Test cases
-spec test() -> _.

-spec success_test() -> _.
success_test() ->
    Pet = jsx:decode(<<"{
        \"type\":         \"Cat\",
        \"name\":         \"Flaffy\",
        \"huntingSkill\": \"adventurous\",
        \"owner\": {
            \"type\":      \"Person\",
            \"soleOwner\": true,
            \"name\":      \"Robin\",
            \"age\":       12,
            \"sex\":       \"male\",
            \"legalStatus\": {
                \"status\": \"Single\",
                \"minor\":  true
            }
        }
    }">>),
    ?assertEqual(Pet, validate(?PET_SCHEMA, Pet)).

-spec wrong_cat_test() -> _.
wrong_cat_test() ->
    Pet = jsx:decode(<<"{
        \"name\": \"Fluffy\",
        \"type\": \"Cat\",
        \"huntingSkill\": \"wrong\"
    }">>),
    Expect = exception(<<"#/definitions/Pet">>, Pet, []),
    ?assertEqual(Expect, validate(?PET_SCHEMA, Pet)).

-spec person_sex_missing_test() -> _.
person_sex_missing_test() ->
    Pet = jsx:decode(<<"{
        \"type\":         \"Cat\",
        \"name\":         \"Fluffy\",
        \"huntingSkill\": \"adventurous\",
        \"owner\": {
            \"type\":      \"Person\",
            \"soleOwner\": true,
            \"name\":      \"true\",
            \"age\":       12,
            \"legalStatus\": {
                \"status\": \"Single\",
                \"minor\":  true
            }
        }
    }">>),
    Expect = exception(<<"#/definitions/Owner">>, jesse_json_path:path(<<"owner">>, Pet), [<<"owner">>]),
    ?assertEqual(Expect, validate(?PET_SCHEMA, Pet)).

-spec legal_status_minor_flag_missing_test() -> _.
legal_status_minor_flag_missing_test() ->
    Pet = jsx:decode(<<"{
        \"type\":         \"Cat\",
        \"name\":         \"Fluffy\",
        \"huntingSkill\": \"adventurous\",
        \"owner\": {
            \"type\":      \"Person\",
            \"soleOwner\": true,
            \"name\":      \"true\",
            \"age\":       12,
            \"sex\":       \"male\",
            \"legalStatus\": {
                \"status\": \"Single\"
            }
        }
    }">>),
    Expect = exception(<<"#/definitions/Owner">>, jesse_json_path:path(<<"owner">>, Pet), [<<"owner">>]),
    ?assertEqual(Expect, validate(?PET_SCHEMA, Pet)).

-endif.
