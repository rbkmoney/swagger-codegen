-module({{packageName}}_schema_validator).

-behaviour(gen_server).

-export([child_spec/2]).
-export([get_validator/1]).

-export([start_link/0]).
-export([validate/3]).

-export([init/1]).
-export([handle_call/3]).
-export([handle_cast/2]).
-export([handle_info/2]).
-export([code_change/3]).
-export([terminate/2]).

-export_type([defname/0]).
-export_type([validator/0]).
-export_type([pool_options/0]).

-define(DEFAULT_SCHEMA_VER, <<"http://json-schema.org/draft-04/schema#">>).

-type json() :: jsx:json_term().
-type defname() :: binary().
-type error_reason() :: binary().
-type validator() :: fun((json(), defname()) -> ok | {error, [error_reason()] | unavailable}).

-type pool_time_interval() :: {non_neg_integer(), min | sec | ms}.
-type pool_options() :: #{
    name                 => term(),
    start_mfa            => {atom(), atom(), start_args()},
    max_count            => non_neg_integer(),
    init_count           => non_neg_integer(),
    cull_interval        => pool_time_interval(),
    max_age              => pool_time_interval(),
    member_start_timeout => pool_time_interval()
}.

-type start_args() :: #{
    schema_ver => binary()
}.

-define(DEFAULT_POOL_OPTIONS, #{
    init_count => 1,
    max_count  => 20,
    start_mfa => {?MODULE, start_link, [#{}]}
}).

-define(DEFAULT_TAKE_TIMEOUT, {3, sec}).

-spec child_spec(ID :: atom(), PoolOptions :: pool_options()) ->
    supervisor:child_spec().

child_spec(ID, PoolOptions) ->
    pooler:pool_child_spec(maps:to_list(
        maps:merge(
            maps:merge(?DEFAULT_POOL_OPTIONS, PoolOptions),
            #{
                name => construct_pool_name(ID)
            }
        )
    )).

-spec validate(ID :: atom(), json(), defname()) ->
    ok | {error, [error_reason()] | unavailable}.

validate(ID, Json, Defname) ->
    validate_(construct_pool_name(ID), Json, Defname).

validate_(PoolName, Json, Defname) ->
    case pooler:take_member(PoolName, ?DEFAULT_TAKE_TIMEOUT) of
        Pid when is_pid(Pid) ->
            try
                Result = do_validate(Pid, Json, Defname),
                ok = pooler:return_member(PoolName, Pid, ok),
                Result
            catch Class:Reason ->
                ok = pooler:return_member(PoolName, Pid, fail),
                erlang:raise(Class, Reason, erlang:get_stacktrace())
            end;
        error_no_members ->
            {error, unavailable}
    end.

-spec get_validator(ID :: atom()) ->
    validator().

get_validator(ID) ->
    PoolName = construct_pool_name(ID),
    fun (Json, Defname) ->
        validate_(PoolName, Json, Defname)
    end.

-spec start_link() ->
    {ok, pid()}.

start_link() ->
    gen_server:start_link(?MODULE, [], []).

%%

construct_pool_name(ID) ->
    binary_to_atom(<<?MODULE_STRING, $_, (atom_to_binary(ID, utf8))/binary>>, utf8).

do_validate(Pid, Json, Defname) ->
    gen_server:call(Pid, {validate, Json, Defname}).

%%

-type state() ::
    jesse_state:state().

-spec init(_) ->
    {ok, state()}.

init(Options) ->
    SchemaVer = maps:get(schema_ver, Options, ?DEFAULT_SCHEMA_VER),
    Schema = get_swagger_schema(),
    {ok, prepare_validator(Schema, SchemaVer)}.

-spec handle_call({validate, json(), defname()} | _, _From, state()) ->
    {reply, ok | {error, [term()]}, state()} | {noreply, state()}.

handle_call({validate, Json, Defname}, _From, State) ->
    try
        ResultState = jesse_schema_validator:validate_with_state(
            [{<<"$ref">>, Defname}],
            Json,
            State
        ),
        ok = check_result(ResultState),
        {reply, ok, State}
    catch
        throw:Errors when is_list(Errors) ->
            Reasons = [map_error_reason(E) || E <- Errors],
            {reply, {error, Reasons}, State}
    end;

handle_call(_Call, _From, State) ->
    {noreply, State}.

-spec handle_cast(_Cast, state()) ->
    {noreply, state()}.

handle_cast(_Cast, State) ->
    {noreply, State}.

-spec handle_info(_Info, state()) ->
    {noreply, state()}.

handle_info(_Info, State) ->
    {noreply, State}.

-spec code_change(_, state(), _) ->
    {ok, state()}.
code_change(_, State, _) ->
    {ok, State}.

-spec terminate(_Reason, state()) ->
    ok.
terminate(_, _) ->
    ok.

map_error_reason({
    'data_invalid',
    _Schema,
    Error,
    _Data,
    Path0
}) ->
    Path = get_error_path(Path0),
    Description = get_error_description(Error),
    {{packageName}}_utils:join(".", [Description, Path]).

get_error_description(all_schemas_not_valid) ->
    {schema_violated, <<"Schema rule \"AllOf\" violated">>};

get_error_description(any_schemas_not_valid) ->
    {schema_violated, <<"Schema rule \"AnyOf\" violated">>};

get_error_description({missing_dependency, Dependency0}) ->
    Dependency = {{packageName}}_utils:to_binary(Dependency0),
    {schema_violated, <<"Missing dependency \"", Dependency/binary>>};

get_error_description(missing_required_property) ->
    <<"Missing required property">>;

get_error_description(no_extra_items_allowed) ->
    <<"Extra items not allowed">>;

get_error_description(no_extra_properties_allowed) ->
    <<"Extra properties not allowed">>;

get_error_description(no_match) ->
    <<"No match to pattern">>;

get_error_description(not_found) ->
    <<"Not found">>;

get_error_description(not_in_range) ->
    <<"Not in range">>;

get_error_description(not_multiple_of) ->
     <<"Schema rule \"MultipleOf\" violated">>;

get_error_description(not_one_schema_valid) ->
    <<"Schema rule \"OneOf\" violated">>;

get_error_description(not_schema_valid) ->
    <<"Schema rule \"Not\" violated">>;

get_error_description(too_few_properties) ->
    <<"Too few properties">>;

get_error_description(too_many_properties) ->
     <<"Too many properties">>;

get_error_description(wrong_length) ->
    <<"Wrong length">>;

get_error_description(wrong_size) ->
    <<"Wrong size">>;

get_error_description(wrong_type) ->
    <<"Wrong type">>.

get_error_path([]) ->
    <<"">>;

get_error_path(Path) ->
    PreparedPath = {{packageName}}_utils:join(".", Path),
    <<"Path to item: ", PreparedPath/binary>>.
%%

prepare_validator(Schema, SchemaVer) ->
    jesse_state:new(Schema, [{default_schema_ver, SchemaVer}]).

get_swagger_schema() ->
    {ok, AppName} = application:get_application(?MODULE),
    Filepath = filename:join({{packageName}}_utils:priv_dir(AppName), "swagger.json"),
    {ok, Contents} = file:read_file(Filepath),
    jsx:decode(Contents).

-spec check_result(state()) -> ok | no_return().

check_result(State) ->
    ErrorList = jesse_state:get_error_list(State),
    case ErrorList of
        [] -> ok;
        _  -> throw(ErrorList)
    end.
