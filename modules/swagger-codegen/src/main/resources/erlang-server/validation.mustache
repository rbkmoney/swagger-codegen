-module({{packageName}}_validation).

-export([prepare_request_param/3]).
-export([validate_response/2]).

-type validation_error() :: #{
    type := error_type(),
    description => binary()
}.

-type error_type() ::
    no_match |
    not_found |
    not_in_range |
    wrong_length |
    wrong_size |
    schema_violated |
    wrong_type.

-type value() :: term().

-export_type([validation_error/0]).
-export_type([error_type/0]).
-export_type([value/0]).

-define(catch_error(Block),
    try
        {ok, Block}
    catch
        throw:{wrong_param, _Name, Errors} ->
            {error, Errors};
        throw:Reason ->
            {error, Reason}
    end
).

-spec prepare_request_param(
    [{{packageName}}_validation_schema:rule()],
    {{packageName}}_validation_schema:param_name(),
    value()
) ->
    {ok, term()} |
    {error, validation_error() | unavailable}.

prepare_request_param(Rules, Name, Value) ->
    ?catch_error(validate_param(Rules, Name, Value)).

-spec validate_response(
    {{packageName}}_validation_schema:response_spec(),
    value()
) ->
    ok |
    {error, validation_error() | unavailable}.

validate_response({DataType, BaseType}, Body) ->
    Result = case DataType of
        'list' ->
            ?catch_error(
                [validate(schema, BaseType, Item) || Item <- Body]
            );
        _ ->
            ?catch_error(validate(schema, BaseType, Body))
    end,
    case Result of
        E = {error, _} -> E;
        _ -> ok
    end;

validate_response(undefined, undefined) ->
    ok;

validate_response(undefined, _) ->
    #{
        type => schema_violated,
        description => <<"Must be empty">>
    }.

validate(Rule = {'list', Format, Ruleset}, Name, Value) ->
    try
        Values = parse_collection_value(Format, Value),
        {ok, [validate_param(Ruleset, Name, V) || V <- Values]}
    catch
        error:badarg ->
            report_validation_error(Rule, Name)
    end;

validate(Rule = schema, Name, Value) ->
    case {{packageName}}_schema_validator:validate(Value, Name) of
        ok ->
            ok;
        {error, Reasons} when is_list(Reasons) ->
            Errors = [map_error(Rule, R) || R <- Reasons],
            report_validation_errors(Name, Errors)
    end;

validate(Rule, Name, Value) ->
    case {{packageName}}_param_validator:validate(Rule, Value) of
        ok ->
            ok;
        Ok = {ok, _} ->
            Ok;
        error ->
            report_validation_error(Rule, Name)
    end.

-spec report_validation_error(
    {{packageName}}_validation_schema:rule(),
    {{packageName}}_validation_schema:param_name()
) ->
    no_return().

report_validation_error(Rule, Name) ->
    Errors = [map_error(Rule)],
    report_validation_errors(Name, Errors).

-spec report_validation_errors(
    {{packageName}}_validation_schema:param_name(),
    [{{packageName}}_validation:validation_error()]
) ->
    no_return().

report_validation_errors(Name, Errors) ->
    throw({wrong_param, Name, Errors}).

validate_param(Rules, Name, Value) ->
    lists:foldl(
        fun(Rule, Acc) ->
            case validate(Rule, Name, Acc) of
                ok -> Acc;
                {ok, Prepared} -> Prepared
            end
        end,
        Value,
        Rules
    ).

map_error(Rule) ->
    map_error(Rule, undefined).

map_error(Rule, Description) ->
    Error = #{
        type => map_violated_rule(Rule)
    },
    case Description of
        undefined -> Error;
        _ -> Error#{description => Description}
    end.

-spec map_violated_rule(
    {{packageName}}_validation_schema:rule()
) ->
    error_type().

map_violated_rule({type, _Type}) ->  wrong_type;
map_violated_rule({enum, _}) ->  not_in_range;
map_violated_rule({max, _, _}) ->  wrong_size;
map_violated_rule({min, _, _}) ->  wrong_size;
map_violated_rule({max_length, _}) ->  wrong_length;
map_violated_rule({min_length, _}) ->  wrong_length;
map_violated_rule({pattern, _}) ->  no_match;
map_violated_rule(schema) ->  schema_violated;
map_violated_rule({required, _}) ->  not_found.

-spec parse_collection_value(
    Format     :: 'csv' | 'ssv' | 'tsv' | 'pipes',
    Collection :: binary()
) ->
    Values :: [binary()].

parse_collection_value(Format, Collection) ->
    binary:split(Collection, get_split_pattern(Format), [global]).

get_split_pattern('csv') ->
    <<",">>;
get_split_pattern('ssv') ->
    <<" ">>;
get_split_pattern('tsv') ->
    <<"\t">>;
get_split_pattern('pipes') ->
    <<"|">>.
