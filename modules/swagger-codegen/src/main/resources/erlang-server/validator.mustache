-module({{packageName}}_validator).

-export([child_spec/2]).
-export([get_validator/1]).

-export([start_link/0]).
-export([validate/3]).

-export([init/1]).
-export([handle_call/3]).
-export([handle_cast/2]).
-export([handle_info/2]).
-export([code_change/3]).
-export([terminate/2]).

-export_type([defname/0]).
-export_type([validator/0]).
-export_type([pool_options/0]).

-type json() :: jsx:json_term().
-type defname() :: binary().
-type validate_error() :: {{packageName}}_api:validation_error().
-type validator() :: fun((json(), defname()) -> ok | {error, {{packageName}}_api:validation_error() | unavailable}).

-type pool_time_interval() :: {non_neg_integer(), min | sec | ms}.
-type pool_options() :: #{
    name                 => term(),
    start_mfa            => {atom(), atom(), list()},
    max_count            => non_neg_integer(),
    init_count           => non_neg_integer(),
    cull_interval        => pool_time_interval(),
    max_age              => pool_time_interval(),
    member_start_timeout => pool_time_interval()
}.

-define(DEFAULT_POOL_OPTIONS, #{
    init_count => 1,
    max_count  => 20
}).

-define(DEFAULT_TAKE_TIMEOUT, {3, sec}).

-spec child_spec(ID :: atom(), PoolOptions :: pool_options()) ->
    supervisor:child_spec().

child_spec(ID, PoolOptions) ->
    pooler:pool_child_spec(maps:to_list(
        maps:merge(
            maps:merge(?DEFAULT_POOL_OPTIONS, PoolOptions),
            #{
                name      => construct_pool_name(ID),
                start_mfa => {?MODULE, start_link, []}
            }
        )
    )).

-spec validate(ID :: atom(), json(), defname()) ->
    ok | {error, [validate_error()] | unavailable}.

validate(ID, Json, Defname) ->
    validate_(construct_pool_name(ID), Json, Defname).

validate_(PoolName, Json, Defname) ->
    case pooler:take_member(PoolName, ?DEFAULT_TAKE_TIMEOUT) of
        Pid when is_pid(Pid) ->
            try
                Result = do_validate(Pid, Json, Defname),
                ok = pooler:return_member(PoolName, Pid, ok),
                Result
            catch Class:Reason ->
                ok = pooler:return_member(PoolName, Pid, fail),
                erlang:raise(Class, Reason, erlang:get_stacktrace())
            end;
        error_no_members ->
            {error, unavailable}
    end.

-spec get_validator(ID :: atom()) ->
    validator().

get_validator(ID) ->
    PoolName = construct_pool_name(ID),
    fun (Json, Defname) ->
        validate_(PoolName, Json, Defname)
    end.

-spec start_link() ->
    {ok, pid()}.

start_link() ->
    gen_server:start_link(?MODULE, [], []).

%%

construct_pool_name(ID) ->
    binary_to_atom(<<?MODULE_STRING, $_, (atom_to_binary(ID, utf8))/binary>>, utf8).

do_validate(Pid, Json, Defname) ->
    gen_server:call(Pid, {validate, Json, Defname}).

%%

-type state() ::
    jesse_state:state().

-spec init(_) ->
    {ok, state()}.

init(_) ->
    Schema = get_swagger_schema(),
    {ok, prepare_validator(Schema)}.

-spec handle_call({validate, json(), defname()} | _, _From, state()) ->
    {reply, ok | {error, [term()]}, state()} | {noreply, state()}.

handle_call({validate, Json, Defname}, _From, State) ->
    try
        %%% DEAL WITH NON ok response
        _ = jesse_schema_validator:validate_with_state(
            [{<<"$ref">>, Defname}],
            Json,
            State
        ),
        {reply, ok, State}
    catch
        throw:Errors when is_list(Errors) ->
            ValidationErrors = [map_error(E) || E <- Errors],
            {reply, {error, ValidationErrors}, State}
    end;

handle_call(_Call, _From, State) ->
    {noreply, State}.

-spec handle_cast(_Cast, state()) ->
    {noreply, state()}.

handle_cast(_Cast, State) ->
    {noreply, State}.

-spec handle_info(_Info, state()) ->
    {noreply, state()}.

handle_info(_Info, State) ->
    {noreply, State}.

-spec code_change(_, state(), _) ->
    {ok, state()}.
code_change(_, State, _) ->
    {ok, State}.

-spec terminate(_Reason, state()) ->
    ok.
terminate(_, _) ->
    ok.

map_error({
    'data_invalid',
    _Schema,
    Error,
    _Data,
    Path0
}) ->
    Path = get_error_path(Path0),
    {ErrorType, Description} = map_error_(Error),
    #{
        type => ErrorType,
        description => <<Description/binary, Path/binary>>
    }.

map_error_(all_schemas_not_valid) ->
    {schema_violated, <<"">>};

map_error_(any_schemas_not_valid) ->
    {schema_violated, <<"Schema rule \"Any\" violated.">>};

map_error_({missing_dependency, Dependency0}) ->
    Dependency = {{packageName}}_utils:to_binary(Dependency0),
    {schema_violated, <<"Missing dependency \"", Dependency/binary, "\".">>};

map_error_(missing_required_property) ->
    {schema_violated, <<"Missing required property.">>};

map_error_(no_extra_items_allowed) ->
    {schema_violated, <<"Extra items not allowed.">>};

map_error_(no_extra_properties_allowed) ->
    {schema_violated, <<"Extra properties not allowed.">>};

map_error_(no_match) ->
    {no_match, <<"">>};

map_error_(not_found) ->
    {not_found, <<"">>};

map_error_(not_in_range) ->
    {not_in_range, <<"">>};

map_error_(not_multiple_of) ->
    {not_multiple_of,  <<"Schema rule \"MultipleOf\" violated.">>};

map_error_(not_one_schema_valid) ->
    {schema_violated, <<"Schema rule \"OneOf\" violated.">>};

map_error_(not_schema_valid) ->
    {schema_violated, <<"Schema rule \"Not\" violated.">>};

map_error_(too_few_properties) ->
    {schema_violated, <<"Too few properties.">>};

map_error_(too_many_properties) ->
    {schema_violated,  <<"Too many properties.">>};

map_error_(wrong_length) ->
    {wrong_length, <<"">>};

map_error_(wrong_size) ->
    {wrong_size, <<"">>};

map_error_(wrong_type) ->
    {wrong_type, <<"">>}.

get_error_path([]) ->
    <<"">>;

get_error_path(Path) ->
    PreparedPath = {{packageName}}_utils:join(".", Path),
    <<"Path to item: ", PreparedPath/binary>>.
%%

prepare_validator(Schema) ->
    jesse_state:new(Schema, [{default_schema_ver, <<"http://json-schema.org/draft-04/schema#">>}]).

get_swagger_schema() ->
    {ok, AppName} = application:get_application(?MODULE),
    Filepath = filename:join({{packageName}}_utils:priv_dir(AppName), "swagger.json"),
    {ok, Contents} = file:read_file(Filepath),
    jsx:decode(Contents).
