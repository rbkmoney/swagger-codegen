-module({{packageName}}_api).

-export([request_params/1]).
-export([request_param_info/2]).
-export([populate_request/3]).
-export([validate_response/4]).

-type operation_id() :: atom().
-type request_param() :: atom().


-type request_context() :: #{
    auth_context => AuthContext :: {{packageName}}_auth:context(),
    peer => client_peer()
}.

-type client_peer() :: #{
    ip_address => IP :: inet:ip_address(),
    port_number => Port :: inet:port_number()
}.

-type rule() ::
    {type, 'binary'} |
    {type, 'integer'} |
    {type, 'float'} |
    {type, 'boolean'} |
    {type, 'date'} |
    {type, 'datetime'} |
    {enum, [atom()]} |
    {max, Max :: number(), Type :: exclusive | inclusive} |
    {min, Min :: number(), Type :: exclusive | inclusive} |
    {max_length, MaxLength :: integer()} |
    {min_length, MaxLength :: integer()} |
    {pattern, Pattern :: string()} |
    schema |
    {required, boolean()}.

-type validation_error() :: #{
    type := error_type(),
    description => binary()
}.

-type error_type() ::
    no_match |
    not_found |
    not_in_range |
    not_multiple_of |
    wrong_length |
    wrong_size |
    schema_violated |
    wrong_type.


-export_type([operation_id/0]).
-export_type([request_context/0]).
-export_type([client_peer/0]).
-export_type([validation_error/0]).
-export_type([error_type/0]).

-spec request_params(OperationID :: operation_id()) -> [Param :: request_param()].
{{#apiInfo}}{{#apis}}
{{#operations}}{{#operation}}
request_params('{{operationId}}') ->
    [{{#allParams}}{{^isBodyParam}}
        '{{baseName}}'{{/isBodyParam}}{{#isBodyParam}}
        '{{dataType}}'{{/isBodyParam}}{{#hasMore}},{{/hasMore}}{{/allParams}}
    ];
{{/operation}}{{/operations}}{{/apis}}{{/apiInfo}}
request_params(_) ->
    error(unknown_operation).

-spec request_param_info(OperationID :: operation_id(), Name :: request_param()) -> #{
    source => qs_val | binding | header | body,
    rules => [rule()]
}.

{{#apiInfo}}{{#apis}}
{{#operations}}{{#operation}}{{#allParams}}
request_param_info('{{operationId}}', {{^isBodyParam}}'{{baseName}}'{{/isBodyParam}}{{#isBodyParam}}'{{dataType}}'{{/isBodyParam}}) ->
    #{
        source => {{#isQueryParam}}qs_val{{/isQueryParam}} {{#isPathParam}}binding{{/isPathParam}} {{#isHeaderParam}}header{{/isHeaderParam}}{{#isBodyParam}}body{{/isBodyParam}},
        rules => {{#isListContainer}}[{list, '{{collectionFormat}}', {{#items}}[{{>api.param_info}}]{{/items}}}, {{>api.param_info}}]{{/isListContainer}}{{^isListContainer}}[{{>api.param_info}}]{{/isListContainer}}
    };
{{/allParams}}{{/operation}}{{/operations}}{{/apis}}{{/apiInfo}}
request_param_info(OperationID, Name) ->
    error({unknown_param, OperationID, Name}).

-spec populate_request(
    OperationID :: operation_id(),
    Req :: cowboy_req:req(),
    Validator :: {{packageName}}_validator:validator()
) ->
    {ok, Model :: #{}, Req :: cowboy_req:req()} |
    {error, Reason :: unavailable | binary(), Req :: cowboy_req:req()}.

populate_request(OperationID, Req, Validator) ->
    Params = request_params(OperationID),
    populate_request_params(OperationID, Params, Req, Validator, #{}).

populate_request_params(_, [], Req, _, Model) ->
    {ok, Model, Req};

populate_request_params(OperationID, [FieldParams | T], Req0, Validator, Model) ->
    case populate_request_param(OperationID, FieldParams, Req0, Validator) of
        {ok, K, V, Req} ->
            populate_request_params(OperationID, T, Req, Validator, maps:put(K, V, Model));
        Error ->
            Error
    end.

populate_request_param(OperationID, Name, Req0, Validator) ->
    #{rules := Rules, source := Source} = request_param_info(OperationID, Name),
    {Value, Req} = get_value(Source, Name, Req0),
    case prepare_param(Rules, Name, Value, Validator) of
        {ok, Result} -> {ok, Name, Result, Req};
        {error, Reason} ->
            {error, Reason, Req}
    end.

-spec validate_response(
    OperationID :: operation_id(),
    Code :: 200..599,
    Body :: jesse:json_term(),
    Validator :: {{packageName}}_validator:validator()
) -> ok | no_return().
{{#apiInfo}}{{#apis}}
{{#operations}}{{#operation}}
{{#responses}}
validate_response('{{operationId}}', {{code}}, Body, Validator) ->
    validate_response_body('{{dataType}}', '{{baseType}}', Body, Validator);
{{/responses}}
{{/operation}}{{/operations}}{{/apis}}{{/apiInfo}}

validate_response(_OperationID, _Code, _Body, _Validator) ->
    ok.

validate_response_body('list', ReturnBaseType, Body, Validator) ->
    [
        validate(schema, ReturnBaseType, Item, Validator)
    || Item <- Body];

validate_response_body(_, ReturnBaseType, Body, Validator) ->
    validate(schema, ReturnBaseType, Body, Validator).

%%%

validate(Rule = {required, Req}, Name, Value, _Validator) ->
    case Value of
        undefined when Req -> validation_error(Rule, Name);
        _ -> ok
    end;

validate(_, _Name, undefined, _Validator) ->
    ok;

validate(Rule = {type, 'integer'}, Name, Value, _Validator) ->
    try
        {ok, {{packageName}}_utils:to_int(Value)}
    catch
        error:badarg ->
            validation_error(Rule, Name)
    end;

validate(Rule = {type, 'float'}, Name, Value, _Validator) ->
    try
        {ok, {{packageName}}_utils:to_float(Value)}
    catch
        error:badarg ->
            validation_error(Rule, Name)
    end;

validate(Rule = {type, 'binary'}, Name, Value, _Validator) ->
    case is_binary(Value) of
        true -> ok;
        false -> validation_error(Rule, Name)
    end;

validate(_Rule = {type, 'boolean'}, _Name, Value, _Validator) when is_boolean(Value) ->
    {ok, Value};

validate(Rule = {type, 'boolean'}, Name, Value, _Validator) ->
    V = binary_to_lower(Value),
    try
        case binary_to_existing_atom(V, utf8) of
            B when is_boolean(B) -> {ok, B};
            _ -> validation_error(Rule, Name)
        end
    catch
        error:badarg ->
            validation_error(Rule, Name)
    end;

validate(Rule = {type, 'date'}, Name, Value, _Validator) ->
    case is_binary(Value) of
        true ->
            case validate_date(Value) of
                {ok, _} ->
                    ok;
                {error, _} ->
                    validation_error(Rule, Name)
            end;
        false -> validation_error(Rule, Name)
    end;

validate(Rule = {type, 'datetime'}, Name, Value, _Validator) ->
    case is_binary(Value) of
        true ->
            case validate_datetime(Value) of
                {ok, _} ->
                    ok;
                {error, _} ->
                    validation_error(Rule, Name)
            end;
        false -> validation_error(Rule, Name)
    end;

validate(Rule = {enum, Values}, Name, Value, _Validator) ->
    try
        FormattedValue = erlang:binary_to_existing_atom(Value, utf8),
        case lists:member(FormattedValue, Values) of
            true -> {ok, FormattedValue};
            false -> validation_error(Rule, Name)
        end
    catch
        error:badarg ->
            validation_error(Rule, Name)
    end;

validate(Rule = {max, Max, Type}, Name, Value, _Validator) ->
    Result = case Value of
        _ when Value < Max andalso Type =:= exclusive ->
            true;
        _ when Value =< Max andalso Type =:= inclusive  ->
            true;
        _ ->
            false
    end,
    case Result of
        true -> ok;
        false -> validation_error(Rule, Name)
    end;

validate(Rule = {min, Min, Type}, Name, Value, _Validator) ->
    Result = case Value of
        _ when Value > Min andalso Type =:= exclusive ->
            true;
        _ when Value >= Min andalso Type =:= inclusive ->
            true;
        _ ->
            false
    end,
    case Result of
        true -> ok;
        false -> validation_error(Rule, Name)
    end;

validate(Rule = {max_length, MaxLength}, Name, Value, _Validator) ->
    case size(Value) =< MaxLength of
        true -> ok;
        false -> validation_error(Rule, Name)
    end;

validate(Rule = {min_length, MinLength}, Name, Value, _Validator) ->
    case size(Value) >= MinLength of
        true -> ok;
        false -> validation_error(Rule, Name)
    end;

validate(Rule = {pattern, Pattern}, Name, Value, _Validator) ->
    {ok, MP} = re:compile(Pattern),
    case re:run(Value, MP) of
        {match, _} -> ok;
        _ -> validation_error(Rule, Name)
    end;

validate(Rule = {list, Format, Ruleset}, Name, Value, Validator) ->
    try
        Values = parse_collection_value(Format, Value),
        {ok, [validate_param(Ruleset, Name, V, Validator) || V <- Values]}
    catch
        error:badarg ->
            validation_error(Rule, Name)
    end;

validate(_Rule = schema, Name, Value, Validator) ->
    Defname = list_to_binary("#/definitions/" ++ {{packageName}}_utils:to_list(Name)),
    case Validator(Value, Defname) of
        ok ->
            ok;
        {error, Errors} when is_list(Errors) ->
            report_validation_errors(Name, Errors)
    end;

validate(Rule, Name, _Value, _Validator) ->
    error_logger:info_msg("Can't validate ~p with ~p", [Name, Rule]),
    error({unknown_validation_rule, Rule}).

-spec parse_collection_value(Format :: 'csv' | 'ssv' | 'tsv' | 'pipes', binary()) -> Values :: [binary()].

parse_collection_value(Format, Collection) ->
    binary:split(Collection, get_split_pattern(Format), [global]).

get_split_pattern('csv') ->
    <<",">>;
get_split_pattern('ssv') ->
    <<" ">>;
get_split_pattern('tsv') ->
    <<"\t">>;
get_split_pattern('pipes') ->
    <<"|">>.

-spec validation_error(Rule :: any(), Name :: request_param()) -> no_return().

validation_error(Rule, Name) ->
    Errors = [map_violated_rule(Rule)],
    report_validation_errors(Name, Errors).

-spec report_validation_errors(Name :: request_param(), [validation_error()]) -> no_return().

report_validation_errors(Name, Errors) ->
    throw({wrong_param, Name, Errors}).

get_value(body, _Name, Req0) ->
    {ok, Body, Req} = cowboy_req:body(Req0),
    Value = prepare_body(Body),
    {Value, Req};

get_value(qs_val, Name, Req0) ->
    {QS, Req} = cowboy_req:qs_vals(Req0),
    Value = {{packageName}}_utils:get_opt({{packageName}}_utils:to_qs(Name), QS),
    {Value, Req};

get_value(header, Name, Req0) ->
    {Headers, Req} = cowboy_req:headers(Req0),
    Value = {{packageName}}_utils:get_opt({{packageName}}_utils:to_header(Name), Headers),
    {Value, Req};

get_value(binding, Name, Req0) ->
    {Bindings, Req} = cowboy_req:bindings(Req0),
    Value = {{packageName}}_utils:get_opt({{packageName}}_utils:to_binding(Name), Bindings),
    {Value, Req}.

prepare_body(Body) ->
    case Body of
        <<"">> -> <<"">>;
        _ -> jsx:decode(Body, [return_maps])
    end.

validate_param(Rules, Name, Value, Validator) ->
    lists:foldl(
        fun(Rule, Acc) ->
            case validate(Rule, Name, Acc, Validator) of
                ok -> Acc;
                {ok, Prepared} -> Prepared
            end
        end,
        Value,
        Rules
    ).

prepare_param(Rules, Name, Value, Validator) ->
    try
        {ok, validate_param(Rules, Name, Value, Validator)}
    catch
        throw:{wrong_param, Name, Errors} ->
            Reasons = [get_error_reason(Name, E) || E <- Errors],
            {error, error_message(Reasons)};
        throw:Reason ->
            {error, Reason}
    end.

error_message(Reasons) ->
    {{packageName}}_utils:join("\,", Reasons).

binary_to_lower(V) when is_binary(V) ->
    list_to_binary(string:to_lower({{packageName}}_utils:to_list(V))).

validate_date(Value) when is_binary(Value) ->
    validate_datetime(<<Value/binary, "T00:00:00Z">>).

validate_datetime(Value) when is_binary(Value) ->
    rfc3339:parse(Value).

map_violated_rule({type, Type}) ->
    TypeName = map_type_name(Type),
    #{
        type => wrong_type,
        description => <<"Expected type is \"", TypeName/binary,"\"">>
    };

map_violated_rule({enum, _}) ->
    #{
        type => not_in_range
    };

map_violated_rule({max, _, _}) ->
    #{
        type => wrong_size
    };

map_violated_rule({min, _, _}) ->
    #{
        type => wrong_size
    };

map_violated_rule({max_length, _}) ->
    #{
        type => wrong_length
    };

map_violated_rule({min_length, _}) ->
    #{
        type => wrong_length
    };

map_violated_rule({pattern, _}) ->
    #{
        type => no_match
    };

map_violated_rule({required, _}) ->
    #{
        type => not_found
    }.


-spec get_error_reason(Field :: request_param(), validation_error()) -> binary().

get_error_reason(Field0, Error = #{type := Type}) ->
    Field = {{packageName}}_utils:to_binary(Field0),
    Reason = map_error_reason(Type),
    Desciption = map_error_description(maps:get(description, Error, undefined)),
    <<"Field \"", Field/binary, "\" is not valid. ", Reason/binary, " ", Desciption/binary>>.

map_error_reason(no_match) ->
    <<"Value doesn't match the pattern.">>;

map_error_reason(not_found) ->
    <<"Value not found.">>;

map_error_reason(not_in_range) ->
    <<"Value is not in range of permitted fields.">>;

map_error_reason(wrong_length) ->
    <<"Value has wrong length.">>;

map_error_reason(wrong_size) ->
    <<"Value has wrong type.">>;

map_error_reason(wrong_type) ->
    <<"Value has wrong type.">>;

map_error_reason(schema_violated) ->
    <<"Value violates schema.">>.

map_error_description(undefined) ->
    <<"">>;

map_error_description(Description) when is_binary(Description) ->
    Description.

map_type_name('binary') ->
    <<"string">>;
map_type_name('integer') ->
    <<"integer">>;
map_type_name('float') ->
    <<"number">>;
map_type_name('boolean') ->
    <<"boolean">>;
map_type_name('date') ->
    <<"date">>;
map_type_name('datetime') ->
    <<"date-time">>.

