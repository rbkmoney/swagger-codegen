-module({{packageName}}_api).

-export([request_params/1]).
-export([request_param_info/2]).
-export([populate_request/3]).
-export([validate_response/4]).


{{#apiInfo}}{{#apis}}
{{#operations}}{{#operation}}
request_params('{{operationId}}') ->
    [{{#allParams}}{{^isBodyParam}}
        "{{baseName}}"{{/isBodyParam}}{{#isBodyParam}}
        "{{dataType}}"{{/isBodyParam}}{{#hasMore}},{{/hasMore}}{{/allParams}}
    ];
{{/operation}}{{/operations}}{{/apis}}{{/apiInfo}}
request_params(_) ->
    error(unknown_operation).

{{#apiInfo}}{{#apis}}
{{#operations}}{{#operation}}{{#allParams}}
request_param_info('{{operationId}}', {{^isBodyParam}}"{{baseName}}"{{/isBodyParam}}{{#isBodyParam}}"{{dataType}}"{{/isBodyParam}}) ->
    #{
        source => {{#isQueryParam}}qs_val{{/isQueryParam}} {{#isPathParam}}binding{{/isPathParam}} {{#isHeaderParam}}header{{/isHeaderParam}}{{#isBodyParam}}body{{/isBodyParam}},
        rules => [{{#isString}}
            {type, 'binary'}, {{/isString}}{{#isInteger}}
            {type, 'integer'}, {{/isInteger}}{{#isLong}}
            {type, 'integer'}, {{/isLong}}{{#isFloat}}
            {type, 'float'}, {{/isFloat}}{{#isDouble}}
            {type, 'float'}, {{/isDouble}}{{#isByteArray}}
            {type, 'binary'}, {{/isByteArray}}{{#isBinary}}
            {type, 'binary'}, {{/isBinary}}{{#isBoolean}}
            {type, 'boolean'}, {{/isBoolean}}{{#isDate}}
            {type, 'date'}, {{/isDate}}{{#isDateTime}}
            {type, 'datetime'}, {{/isDateTime}}{{#isEnum}}
            {enum, [{{#allowableValues}}{{#values}}{{.}}{{/values}}{{/allowableValues}}] },{{/isEnum}}{{#required}}
            required, {{/required}}{{#maximum}}
            {max, {{maximum}} }, {{/maximum}}{{#exclusiveMaximum}}
            {exclusive_max, {{exclusiveMaximum}} }, {{/exclusiveMaximum}}{{#minimum}}
            {min, {{minimum}} }, {{/minimum}}{{#exclusiveMinimum}}
            {exclusive_min, {{exclusiveMinimum}} }, {{/exclusiveMinimum}}{{#maxLength}}
            {max_length, {{maxLength}} }, {{/maxLength}}{{#minLength}}
            {min_length, {{minLength}} }, {{/minLength}}{{#pattern}}
            {pattern, "{{pattern}}" }, {{/pattern}}{{#isBodyParam}}
            schema, {{/isBodyParam}}
            ok
        ]
    };
{{/allParams}}{{/operation}}{{/operations}}{{/apis}}{{/apiInfo}}
request_param_info(OperationID, Name) ->
    error({unknown_param, OperationID, Name}).

populate_request(OperationID, Req, ValidatorState) ->
    Params = request_params(OperationID),
    populate_request_params(OperationID, Params, Req, ValidatorState, #{}).

populate_request_params(_, [], Req, _, Model) ->
    {ok, Model, Req};

populate_request_params(OperationID, [FieldParams | T], Req0, ValidatorState, Model) ->
    case populate_request_param(OperationID, FieldParams, Req0, ValidatorState) of
        {ok, K, V, Req} ->
            populate_request_params(OperationID, T, Req, ValidatorState, maps:put(K, V, Model));
        Error ->
            Error
    end.

populate_request_param(OperationID, Name, Req0, ValidatorState) ->
    #{rules := Rules, source := Source} = request_param_info(OperationID, Name),
    {Value, Req} = get_value(Source, Name, Req0),
    case prepare_param(Rules, Name, Value, ValidatorState) of
        {ok, Result} -> {ok, Name, Result, Req};
        {error, Reason} ->
            {error, Reason, Req}
    end.


{{#apiInfo}}{{#apis}}
{{#operations}}{{#operation}}
{{#responses}}
validate_response('{{operationId}}', {{code}}, Body, ValidatorState) ->
    validate_response_body("{{dataType}}", "{{baseType}}", Body, ValidatorState);
{{/responses}}
{{/operation}}{{/operations}}{{/apis}}{{/apiInfo}}

validate_response(_OperationID, _Code, _Body, _ValidatorState) ->
    ok.

validate_response_body(undefined, _, Body, _) ->
    case Body of
        #{} -> ok;
        _ -> throw(invalid_response)
    end;

validate_response_body("list", ReturnBaseType, Body, ValidatorState) ->
    [
        validate(schema, ReturnBaseType, Item, ValidatorState)
    || Item <- Body];

validate_response_body(_, ReturnBaseType, Body, ValidatorState) ->
    validate(schema, ReturnBaseType, Body, ValidatorState).

%%%
validate( Rule = required, Name, Value, _ValidatorState) ->
    case Value of
        undefined -> validation_error(Rule, Name);
        _ -> ok
    end;

validate( _, _Name, undefined, _ValidatorState) ->
    ok;

validate( Rule = {type, 'integer'}, Name, Value, _ValidatorState) ->
    try
        {ok, {{packageName}}_utils:to_int(Value)}
    catch
        _:_ ->
            validation_error(Rule, Name)
    end;

validate( Rule = {type, 'float'}, Name, Value, _ValidatorState) ->
    try
        {ok, {{packageName}}_utils:to_float(Value)}
    catch
        _:_ ->
            validation_error(Rule, Name)
    end;

validate( Rule = {type, 'binary'}, Name, Value, _ValidatorState) ->
    case is_binary(Value) of
        true -> ok;
        false -> validation_error(Rule, Name)
    end;

validate( _Rule = {type, 'boolean'}, _Name, Value, _ValidatorState) when is_boolean(Value) ->
    {ok, Value};

validate( Rule = {type, 'boolean'}, Name, Value, _ValidatorState) ->
    V = binary_to_lower(Value),
    case binary_to_existing_atom(V, utf8) of
        B when is_boolean(B) -> {ok, B};
        _ -> validation_error(Rule, Name)
    end;

validate( Rule = {type, 'date'}, Name, Value, _ValidatorState) ->
    case is_binary(Value) of
        true -> ok;
        false -> validation_error(Rule, Name)
    end;

validate( Rule = {type, 'datetime'}, Name, Value, _ValidatorState) ->
    case is_binary(Value) of
        true -> ok;
        false -> validation_error(Rule, Name)
    end;

validate( Rule = {enum, Values}, Name, Value, _ValidatorState) ->
    case lists:member(Value, Values) of
        true -> ok;
        false -> validation_error(Rule, Name)
    end;

validate( Rule = {max, Max}, Name, Value, _ValidatorState) ->
    case Value >= Max of
        true -> ok;
        false -> validation_error(Rule, Name)
    end;

validate( Rule = {exclusive_max, ExclusiveMax}, Name, Value, _ValidatorState) ->
    case Value > ExclusiveMax of
        true -> ok;
        false -> validation_error(Rule, Name)
    end;

validate( Rule = {min, Min}, Name, Value, _ValidatorState) ->
    case Value =< Min of
        true -> ok;
        false -> validation_error(Rule, Name)
    end;

validate( Rule = {exclusive_min, ExclusiveMin}, Name, Value, _ValidatorState) ->
    case Value =< ExclusiveMin of
        true -> ok;
        false -> validation_error(Rule, Name)
    end;

validate( Rule = {max_length, MaxLength}, Name, Value, _ValidatorState) ->
    case size(Value) =< MaxLength of
        true -> ok;
        false -> validation_error(Rule, Name)
    end;

validate( Rule = {min_length, MinLength}, Name, Value, _ValidatorState) ->
    case size(Value) >= MinLength of
        true -> ok;
        false -> validation_error(Rule, Name)
    end;

validate( Rule = {pattern, Pattern}, Name, Value, _ValidatorState) ->
    {ok, MP} = re:compile(Pattern),
    case re:run(Value, MP) of
        {match, _} -> ok;
        _ -> validation_error(Rule, Name)
    end;

validate( Rule = schema, Name, Value, ValidatorState) ->
    Definition =  list_to_binary("#/definitions/" ++ Name),
    try
        validate_with_schema(Value, Definition, ValidatorState)
    catch
        _:_ ->
            validation_error(Rule, Name)
    end;

validate(ok, _Name, _Value, _ValidatorState) ->
    ok;

validate(Rule, Name, Value, _ValidatorState) ->
    io:format("Skipping unknown validation: ~p~n", [{Rule, Name, Value}]),
    ok.

validation_error(Name, Violated) ->
    throw({wrong_param, Name, Violated}).

get_value(body, _Name, Req0) ->
    {ok, Body, Req} = cowboy_req:body(Req0),
    Value = prepare_body(Body),
    {Value, Req};

get_value(qs_val, Name, Req0) ->
    {QS, Req} = cowboy_req:qs_vals(Req0),
    Value = {{packageName}}_utils:get_opt({{packageName}}_utils:string_to_qs(Name), QS),
    {Value, Req};

get_value(header, Name, Req0) ->
    {Headers, Req} = cowboy_req:headers(Req0),
    Value = {{packageName}}_utils:get_opt({{packageName}}_utils:string_to_header(Name), Headers),
    {Value, Req};

get_value(binding, Name, Req0) ->
    {Bindings, Req} = cowboy_req:bindings(Req0),
    Value = {{packageName}}_utils:get_opt({{packageName}}_utils:string_to_binding(Name), Bindings),
    {Value, Req}.

prepare_body(Body) ->
    case Body of
        <<"">> -> <<"">>;
        _ -> jsx:decode(Body, [return_maps])
    end.

validate_with_schema(Body, Definition, ValidatorState) ->
    jesse_schema_validator:validate_with_state(
        [{<<"$ref">>, Definition}],
        Body,
        ValidatorState
    ).

prepare_param(Rules, Name, Value, ValidatorState) ->
    try
        Result = lists:foldl(
            fun(Rule, Acc) ->
                case validate(Rule, Name, Acc, ValidatorState) of
                    ok -> Acc;
                    {ok, Prepared} -> Prepared
                end
            end,
            Value,
            Rules
        ),
        {ok, Result}
    catch
        throw:Reason ->
            {error, Reason}
    end.

binary_to_lower(V) when is_binary(V) ->
    list_to_binary(string:to_lower({{packageName}}_utils:to_list(V))).
